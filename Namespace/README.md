# Namespace

编程中，乃至数学中一个很重要的问题就是起名称。我们需要用不同的名称指代不同的对象以发生混淆。同时我们希望用尽量少的名称来完成尽量多的事情，这就需要在不引起混淆的情况下，用同样的名称指代不同的对象。这就需要命名空间和名称绑定的机制。

## 合法的名称

C#对名称的要求和大多数编程语言对名称的要求一样——以字母或者下划线开头，仅仅由字母、数字、下划线构成。另外要避开一些在C#中已经有特殊含义单词（称为关键字）。

> 所谓的“关键字”（我更倾向于叫“关键词”）是一些拥有语法意义的单词。为了防止含义冲突，这些词是不能作为变量、函数、类或者命名空间的名称的。

> 不能以数字开头，是为了防止变量名称和数字的字面值发生混淆。相当于通过开头字符将数字字面值和变量名分开。需要注意的是，数字字面值中并不一定不包含字母，例如十六进制的数字`0x12AB`。

## 命名空间

名称的作用就是用于指某个类，字段，方法或者命名空间。

类是C#组织程序的基本单位。每个类肯定都是有名称的。方法，就是类中的函数。字段则是类中或者函数定义中的变量。

> 需要注意的是。一般来说字段的值都是类的实例。比如整数`4`，默认它是类`System.Int32`的一个对象。
>
> 但是方法却不能算是类或者对象。方法（或者说函数）在C#中是一个比较特殊的存在。方法就是方法，对应于语言中的动词（而类和对象对应于语言中的名词）。
>
> 不过就像语言中可以把动词变成动名词，然后当名词使用。C#中可以使用代理（delegate）把方法打包成代理对象。这样一来虽然我们不能直接把方法当作对象进行传递或运算。但是却可以把由它打包成的代理对象进行传递和运算。

而命名空间既不是类，也不是字段，更不是方法。它的意义在于防止重名。我们从一个例子开始：

在《巫师3》中。杰洛特自我介绍的时候都会说“利维亚的杰洛特”。因为小说背景中，平民是没有姓氏，只有名字的。只有贵族家族才有权力使用专有的姓氏（Triss Merigold就有姓氏，Ciri更是有一长串姓氏）。但是英文字母的组合也就那么多，其中有意义的词汇更少。人口一多难免就有重名（鸽巢原理）。这里有一个叫杰洛特的，那里也有一个叫杰洛特的。你叫一声杰洛特可能有好几个人答应。

为了防止混乱，他们会在人名的基础上加上家乡地名。“利维亚的杰洛特”就是说这个杰洛特是来自利维亚的那个。而不是疙瘩屯的那个杰洛特。（“范格堡的叶奈法”同理。）

在这一套称呼方法里，用名字加上地名。实际上加长了全名的长度，也就可以编码更多的人而不发生冲突。但是总说某某地的某某某显得太冗长。所以，一般只有在面对陌生人或者去外地的时候才报全名。如果就在当地，其实可以省略地名。比如疙瘩屯的杰洛特和疙瘩屯的叶奈法，平常在疙瘩屯的时候可以就简称杰洛特和叶奈法，反正地名都一样，没有必要增加麻烦。疙瘩屯的杰洛特只有在和利维亚的杰洛特同时出现，有混淆的可能的时候才用全称。

称呼的时候加上地名防止混淆这种方法，抽象一下就是命名空间机制。我们可能会写很多个叫`Item`的类。为了彼此区分，我们把它们放到不同的命名空间中。这样它们就有了不同的全称。比如`Database.Item`和`Network.Item`，两个`Item`分别存在于`Database`命名空间和`Network`命名空间中。

> 这里的`.`相当于“利维亚的杰洛特”中的“的”（或者英文中的“of”）。这个`.`叫做成员算符，除了访问命名空间中的类，它还能用于访问类对象或者结构体的成员。

那么写程序的时候，如何表示哪个`Item`属于哪个命名空间呢？我们首先要用关键字`namespace`，然后加上命名空间名和一对花括号。这样在这对花括号中写的一切内容都属于这个命名空间。

```C#
namespace Rivia
{
    class Geralt
    {
        
    }
    
    class Ciri
    {
        
    }
}
```

这里的两个类`Geralt`和`Ciri`就都属于`Rivia`命名空间。

> 虽然代码中两个类的全称分别是`Rivia.Geralt`和`Rivia.Ciri`。但是在命名空间内部（`namespace`后的花括号里），提到这两个类的时候，不用冠以命名空间名称。

## 命名空间的嵌套

命名空间中只能写两种东西的定义——类和命名空间。也就是说命名空间中可以嵌套命名空间。这种情况我再做一个类比。有个人叫张小三，是河北人。但是河北可能有很多叫张小三的人。称呼为“河北的张小三”也有可能造成混淆。所以我们进一步称之为“河北唐山的张小三”。这里的“唐山”就是嵌套在命名空间“河北”内部的一个命名空间。

具体看一下代码。

```C#
namespace Rivia
{
    class Geralt1{}
    
    namespace Willowhain
    {
        class Geralt2{}
    }
    
    namespace Kaveldun
    {
        class Geralt3{}
    }
}
```

要以全称访问`Geralt2`应该用`Rivia.Willowhain.Geralt2`。而要在`Geralt1`的定义中使用`Geralt2`则只需要写`Willowhain.Geralt2`。因为`Geralt1`和`Willowhain`同处于`Rivia`这个命名空间下。

> 类定义，函数定义本身也相当于建立了一个命名空间。并且当内部的本地变量和外部的变量重名时，首先认为这个名称是指内部的本地变量。

## 省略命名空间名

假设有两个命名空间`Rivial`和`Vengerberg`。在`Rivial.Geralt`的定义中要访问`Vengerberg.Yennefer`每次都要使用全名。这就非常麻烦。所以可以在代码一开始（`namespace`之前）写一行`using Vengerberg;`。这样访问所有存在于`Vengerberg`命名空间中的名称的时候，都可以省略前边的`Vengerberg`不写。比如`Vengerberg.Yennefer`就直接写成`Yennefer`。

> 要是`Rivial`和`Vengerberg`两个命名空间里各有一个`Yennefer`。并且使用了`using Vengerberg`。那么在`Rivial.Geralt`的代码中访问`Yennefer`是指哪个`Yennefer`呢？根据本地覆盖外部的原则。应当是指`Rivial.Yennefer`。

还有一种方法可以给命名空间起缩写名。同样使用`using`关键字。例如使用`using Ri = Rivial;`之后，`Rivial.Geralt`就可以简写为`Ri.Geralt`。

> `using`引导的省略命名空间名或者缩写命名空间名的代码都是语句。所以要以按C语系的习惯，用`;`作为结尾。

## 合理使用命名空间

命名空间当然是一种避免名称冲突的机制。但是实际上我们也可以把命名空间当作一种代码组织方式。比如把命名空间当作组织模块的方法，被放到同一个命名空间中的类，都是功能上相关或者相近的。C#标准库中的工具就大部分都放到了`System`命名空间。

> 所有命名空间处于一个更大的命名空间中。只不过这个命名空间是默认的，我们也不能给它改名字。
>
> 如果没有本地变量（或者本地子命名空间）重名覆盖等问题。所有我们定义的命名空间名是应该可以任何地方都能访问的。（因为所有代码实质上都处于那个默认的，不用起名字的，最大的命名空间的作用域中。）

## 名称绑定

属于不同命名空间下的名称自然是不会发生混淆。实际上C#中还有一些其他结构也能起到一定的分割命名空间的功能。这就是类定义，函数定义以及一些复合语句内部的名称绑定。

要说明名称绑定，我们先要区分“内部名称”和“外部名称”。所谓的内部名称就是一个类定义（或者函数定义，或者复合语句，下同不再复述）内部定义的名称。比如类的字段和方法的名称就是类的内部名称。而在类以外定义的名称，对于这个类来说就是外部名称。例如有两个类的定义：

```C#
namespace TaiXuan{
    class A{
        public static int x;
    }
    class B{
        public static int y;
    }
}
```

对于`A`来说，字段名`x`就是一个“内部的”名称。而`B`一个对于`A`来说是一个“外部的”名称。不管是外部名称还是内部名称，在不产生命名冲突的时候，都是可以直接写名称访问的。例如`A`的内部要输出`x`直接写`x`就行。`A`内部要声明类型为`A`的变量，也是直接写`A`。至于`y`是`B`的内部的名称，因此对于`A`来说不是直接可见的。在`A`的代码中要引用`B`的`y`字段必须写明`B.y`。

但是当产生名称冲突的时候，直接写名称，默认是访问内部名称。例如：

```C#
class Program{
    private int x = 30;

    static void Main(string[] args){
        int x = 10;
        Console.WriteLine($"The value of inner x is {x}");
        PrintX();
    }

    static void PrintX(){
        Console.WriteLine($"The value of outer x is {x}");
    }
}
```

对于函数`Main`来说有一个外部的`x`和一个内部的`x`。因此访问`x`时优先访问内部`x`，输出`10`。不过你仍然可以通过其他途径，例如`Program.x`来访问被隐藏的外部`x`。

对于函数`PrintX`来说，只有一个外部的`x`，所以访问输出外部`x`，输出`30`。如果有的函数内外都没有`x`，那么访问`x`会报错。

用更规范的说法，类定义、函数定义、复合语句的一对花括号内部以及一个命名空间内，都构成一个变量作用域。在这个作用域内部声明的名称（不一定是变量）都是内部名称（函数的形参以及`for`循环的计数变量等也属于内部名称）。而这个变量作用域所属于的变量作用域中定义的名称是外部名称（例如两个并列的函数定义，它们的函数名对于彼此来说就是外部名称）。当访问一个名称时首先访问内部名称，没有内部名称就访问外部名称。如果外部名称也没有就报错。

> 注意，这里的内部名称，外部名称等都不是加上命名空间名或者类名前缀的“全称”。而是比较简短的，不含有`.`的“短称”。

## 命名规范

C#中主要使用两种命名风格：

- Pascal Case，名称中每一个单词首字母都大写（单词之间没有下划线空隙）。例如`PascalCase`。
- Camel Case，首字母小写，其他写法同Pascal Case。例如`camelCase`。

一般来说C#中的类和方法名使用Pascal Case，其他变量（对象实例）使用Camel Case命名。

