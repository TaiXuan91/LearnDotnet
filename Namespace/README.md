# Namespace

编程中，乃至数学中一个很重要的问题就是起名称。我们需要用不同的名称指代不同的对象以发生混淆。同时我们希望用尽量少的名称来完成尽量多的事情，这就需要在不引起混淆的情况下，用同样的名称指代不同的对象。这就需要命名空间和名称绑定的机制。为了更准确地表述，以后我们使用术语“identifier”来替代“名称”一词。

## 起个名字

### 合法的identifiers

identifiers是那些用于指代C#中命名空间，类型，变量，常量，方法等东西的词。

C#对identifiers的要求和大多数编程语言对identifiers的要求一样——以字母或者下划线开头，仅仅由字母、数字、下划线构成。另外要避开一些在C#中已经有特殊含义单词（称为“keywords”）。

> 所谓的“keywords”是一些拥有语法意义的单词。为了防止含义冲突，这些词是不能作为变量、方法、类或者命名空间的identifiers的。

> 不能以数字开头，是为了防止变量identifiers和数字的字面值发生混淆。相当于通过开头字符将数字字面值和变量名分开。需要注意的是，数字字面值中并不一定不包含字母，例如十六进制的数字`0x12AB`。

### 命名习惯

为了使得代码尽量具有统一的格式，保持代码的可读性。有很多在代码风格上约定俗成的规范。在C#中，主要使用两种命名风格：

- Pascal Case，identifiers中每一个单词首字母都大写（单词之间没有下划线空隙）。例如`PascalCase`。
- Camel Case，首字母小写，其他写法同Pascal Case。例如`camelCase`。

一般来说C#中的类和方法名使用Pascal Case，常量和变量（对象实例）使用Camel Case命名。

> 由于最近几个版本的C#关于delegate以及本地方法等内容的更新。使得虽然不是对象的方法越来越像对象。因此我个人认为把方法，以及方法的delegate用camel case命名也是合理的。

## 命名空间（Namespace）

Identifiers的作用就是用于指某个类，字段，方法或者命名空间。类是C#组织程序的基本单位。方法，就是类中的函数。字段则是类中或者函数定义中的变量。每个类和类中的字段成员，方法成员都是有identifier的。

> 需要注意的是。一般来说字段的值都是类的实例。比如整数`4`，默认它是类`System.Int32`的一个对象。
>
> 但是方法却不能算是类或者对象。方法（或者说函数）在C#中是一个比较特殊的存在。方法就是方法，对应于语言中的动词（而类和对象对应于语言中的名词）。
>
> 不过就像语言中可以把动词变成动名词，然后当名词使用。C#中可以使用委托（delegate）把方法打包成委托对象。这样一来虽然我们不能直接把方法当作对象进行传递或运算。但是却可以把由它打包成的代理对象进行传递和运算。

而命名空间既不是类，也不是字段，更不是方法。它的意义在于防止重名。我们从一个例子开始：

在《巫师3》中。杰洛特自我介绍的时候都会说“利维亚的杰洛特”。因为小说背景中，平民是没有姓氏，只有名字的。只有贵族家族才有权力使用专有的姓氏（Triss Merigold就有姓氏，Ciri更是有一长串姓氏）。但是英文字母的组合也就那么多，其中有意义的词汇更少。人口一多难免就有重名（鸽巢原理）。这里有一个叫杰洛特的，那里也有一个叫杰洛特的。你叫一声杰洛特可能有好几个人答应。

为了防止混乱，他们会在人名的基础上加上家乡地名。“利维亚的杰洛特”就是说这个杰洛特是来自利维亚的那个。而不是疙瘩屯的那个杰洛特。（“范格堡的叶奈法”同理。）

在这一套称呼方法里，用名字加上地名。实际上加长了全名的长度，也就可以编码更多的人而不发生冲突。但是总说某某地的某某某显得太冗长。所以，一般只有在面对陌生人或者去外地的时候才报全名。如果就在当地，其实可以省略地名。比如疙瘩屯的杰洛特和疙瘩屯的叶奈法，平常在疙瘩屯的时候可以就简称杰洛特和叶奈法，反正地名都一样，没有必要增加麻烦。疙瘩屯的杰洛特只有在和利维亚的杰洛特同时出现，有混淆的可能的时候才用全称。

称呼的时候加上地名防止混淆这种方法，抽象一下就是命名空间机制。我们可能会写很多个叫`Item`的类。为了彼此区分，我们把它们放到不同的命名空间中。这样它们就有了不同的全称。比如`Database.Item`和`Network.Item`，两个`Item`分别存在于`Database`命名空间和`Network`命名空间中。

> 这里的`.`相当于“利维亚的杰洛特”中的“的”（或者英文中的“of”）。这个`.`叫做成员算符，除了访问命名空间中的类，它还能用于访问类对象或者结构体的成员。

那么写程序的时候，如何表示哪个`Item`属于哪个命名空间呢？我们首先要用关键字`namespace`，然后加上命名空间名和一对花括号。这样在这对花括号中写的一切内容都属于这个命名空间。

```C#
namespace Rivia
{
    class Geralt
    {
        
    }
    
    class Ciri
    {
        
    }
}
```

这里的两个类`Geralt`和`Ciri`就都属于`Rivia`命名空间。

> 虽然代码中两个类的全称分别是`Rivia.Geralt`和`Rivia.Ciri`。但是在命名空间内部（`namespace`后的花括号里），提到这两个类的时候，不用冠以命名空间的identifier。

### 命名空间的嵌套

命名空间中只能写两种东西的定义——类和命名空间。

> 或许你会注意到命名空间中也能定义结构体之类，枚举，委托类型的东西。但是归根到底，这些东西都是继承自`System.Object`的类型。因此定义它们实际上仍然是在定义类型。

能在命名空间中定义命名空间，也就是说命名空间中可以嵌套命名空间。这种情况我再做一个类比。有个人叫张小三，是河北人。但是河北可能有很多叫张小三的人。称呼为“河北的张小三”也有可能造成混淆。所以我们进一步称之为“河北唐山的张小三”。这里的“唐山”就是嵌套在命名空间“河北”内部的一个命名空间。

具体看一下代码。

```C#
namespace Rivia
{
    class Geralt1{}
    
    namespace Willowhain
    {
        class Geralt2{}
    }
    
    namespace Kaveldun
    {
        class Geralt3{}
    }
}
```

要以全称访问`Geralt2`应该用`Rivia.Willowhain.Geralt2`。而要在`Geralt1`的定义中使用`Geralt2`则只需要写`Willowhain.Geralt2`。因为`Geralt1`和`Willowhain`同处于`Rivia`这个命名空间下。

> 类定义，函数定义本身也相当于建立了一个命名空间。并且当内部的本地变量和外部的变量重名时，首先认为这个identifiers是指内部的本地变量。关于这一套机制，我们稍后详细介绍。

### 省略命名空间名

假设有两个命名空间`Rivial`和`Vengerberg`。在`Rivial.Geralt`的定义中要访问`Vengerberg.Yennefer`每次都要使用全名。这就非常麻烦。所以可以在代码一开始（`namespace`之前）写一行`using Vengerberg;`。这样访问所有存在于`Vengerberg`命名空间中的identifiers的时候，都可以省略前边的`Vengerberg`不写。比如`Vengerberg.Yennefer`就直接写成`Yennefer`。

> 要是`Rivial`和`Vengerberg`两个命名空间里各有一个`Yennefer`。并且使用了`using Vengerberg`。那么在`Rivial.Geralt`的代码中访问`Yennefer`是指哪个`Yennefer`呢？根据本地覆盖外部的原则。应当是指`Rivial.Yennefer`。

还有一种方法可以给命名空间起缩写名。同样使用`using`关键字。例如使用`using Ri = Rivial;`之后，`Rivial.Geralt`就可以简写为`Ri.Geralt`。

> `using`引导的省略命名空间名或者缩写命名空间名的代码都是语句。所以要以按C语系的习惯，用`;`作为结尾。

> 对于类来说，不能直接通过`using`来引用（类内部有可能有非静态成员，直接通过`using`引用类可能会在类实例化之前调用非静态成员造成错误）。例如`using System.Console;`是错误写法。如果想要省略前缀调用一个类中的静态成员需要使用`using static`语句。例如`using static System.Console;`。经过这个声明之后可以直接通过函数名（不需要加前缀）直接调用`System.Console`这个类的的静态成员。例如`WriteLine("hello using!");`。
>
> 此外，通过`using`设置别称的用法是可以给类使用的。例如`using cons = System.Console;`是可以的。经过这个声明之后，写`cons`就相当于写`System.Console`。例如`cons.WriteLine("hello using!");`。

### 合理使用命名空间

命名空间当然是一种避免identifiers冲突的机制。但是实际上我们也可以把命名空间当作一种代码组织方式。比如把命名空间当作组织模块的方法，被放到同一个命名空间中的类，都是功能上相关或者相近的。C#标准库中的工具就大部分都放到了`System`命名空间。

> 所有命名空间处于一个更大的命名空间中。只不过这个命名空间是默认的，我们也不能给它改名字。
>
> 如果没有本地变量（或者本地子命名空间）重名覆盖等问题。所有我们定义的命名空间名是应该可以任何地方都能访问的。（因为所有代码实质上都处于那个默认的，不用起名字的，最大的命名空间的作用域中。）

## Identifiers的作用域

属于不同命名空间下的identifiers自然是不会发生混淆。实际上C#中还有一些其他结构也能起到一定的分割命名空间的功能。这就是类定义，函数定义以及复合语句内部的identifiers绑定。为了方便说明，我们提出一个更为广泛的概念——identifiers的作用域。

> 一个简单的判断作用域的方法——基本上，一对花括号`{}`内就是一个作用域。

在同一个作用域之内不允许出现重名现象。但是在不同的作用域内，可以出现名称相同，但是本质并非同一个事物的现象。同时在作用域内，使用这个作用域内定义的identifiers可以不加任何前缀。

### Identifiers的声明

从命名的角度来说。只要声明后这个名称就存在的。但是从程序执行来说并非如此，例如在函数内部声明变量，但是不初始化变量。虽然变量名是存在的，可以访问的。但是实际上没有分配内存，访问未初始化的变量会出错。

这里我们只介绍Identifiers的声明。我们之前介绍的，命名空间的定义，实际上，就是声明了命名空间的名称。而类定义本身实际上就声明了类名。对于函数成员的定义，实际上也是声明了这些成员名。例如定义了一个函数，就声明了这个函数的函数名。但是对于变量和常量的说明需要特别说明一下。它们可以在类定义中或者函数定义中声明。声明是一种语句，其的一般结构是[类型] [名称]。可以根据需要，在之前再加修饰（例如说明访问限制，说明常量等）。例如：

```C#
int x;
char[] str;
public float y;
```

> C#是一门强类型语言。除了命名空间这种辅助性的机制以外，所有的东西都要与类型有关。类定义本身就是在定义类型。函数也要说明输入输出类型。而对于变量与常量来说，它们都要有所属于的类型。

在声明的同时可以初始化变量例如：

```C#
int x = 32;
```

在把声明和初始化合写的时候。变量的类型信息实际上重复了两遍。一遍是声明本身要说明类型信息，第二遍是从始化变量用的值就能推断出变量的类型（二者必须一致）。为了简便起见，我们可以用`var`关键词取代声明中的类型。这样，编译器会根据初始化的量自动推断Identifiers的类型。例如：

```C#
var x = 3.5;
var y = 'A';
```

把声明和初始化分开也可以，例如函数中可以这样写：

```C#
int x;
x = 32;
```

作为类成员的声明可以不考虑现后顺序。但是在函数定义中，必须先声明再使用（访问和赋值都算使用）。

声明过的Identifiers在声明它的作用域中就“存在”了。而没有声明过的Identifiers就不存在于当前作用域中。不过，通过Identifiers的绑定，可以访问一些没有声明于当前作用域中的Identifiers。

### Identifiers的绑定

在一个作用域内访问一个在该作用域内有定义的identifier，那么只要在这个作用域内使用这个identifier，就是指定义在这个作用域内的那个identifier，而不会涉及作用域外部的identifier。在一个作用域内如果访问一个本作用域没有定义的identifier。就涉及外部identifiers了。

首先，我们要区分“内部identifiers”和“外部identifiers”。所谓的内部identifiers就是一个作用域内部定义的identifiers。比如类的字段和方法的identifiers就是类的内部identifiers。而作用域也是可以嵌套的（例如命名空间里定义命名空间，类定义里定义函数，函数里边定义函数等）。包含当前作用域的作用域中定义的identifiers就是外部identifiers。例如有两个类的定义：

```C#
namespace TaiXuan{
    class A{
        public static int x;
    }
    class B{
        public static int y;
    }
}
```

对于`A`来说，字段名`x`就是一个“内部的”identifier。而`B`一个对于`A`来说是一个“外部的”identifier。不管是外部identifiers还是内部identifiers，在不产生命名冲突的时候，都是可以直接写identifiers访问的。例如`A`的内部要输出`x`直接写`x`就行。`A`内部要声明类型为`A`的变量，也是直接写`A`。至于`y`是`B`的内部的identifiers，因此对于`A`来说不是直接可见的。在`A`的代码中要引用`B`的`y`字段必须写明`B.y`。

但是当产生identifiers冲突的时候，直接写identifiers，默认是访问内部identifiers。例如：

```C#
class Program{
    private int x = 30;

    static void Main(string[] args){
        int x = 10;
        Console.WriteLine($"The value of inner x is {x}");
        PrintX();
    }

    static void PrintX(){
        Console.WriteLine($"The value of outer x is {x}");
    }
}
```

对于函数`Main`来说有一个外部的`x`和一个内部的`x`。因此访问`x`时优先访问内部`x`，输出`10`。不过你仍然可以通过其他途径，例如`Program.x`来访问被隐藏的外部`x`。

对于函数`PrintX`来说，只有一个外部的`x`，所以访问输出外部`x`，输出`30`。如果有的函数内外都没有`x`，那么访问`x`会报错。

> 需要注意的是，如果作用域是由类定义或者函数定义产生的。那么这个类或者函数的名称对于其作用域来说本身是个外部identifier。也就是说，其实你可以在`Main`函数内部定义名为`Main`的变量，并且不会造成冲突。

总结一下，当访问一个identifier时首先访问内部identifier，没有内部identifier就访问外部identifier。如果外部identifier也没有就报错。

> 注意，这里的内部identifiers，外部identifiers等都不是加上命名空间名或者类名前缀的“全称”。而是比较简短的，不含有`.`的“短称”。

### 方法多次执行和类实例

从程序的执行机制上讲。同一个方法的多次调用，是相互独立的。因此同一个方法的两次不同调用之间，不会对对方的内部identifiers造成影响。

> 方法的参数对于方法来说是内部identifiers。

举个例子：

```C#
using System;
namespace Demo{
class Program
{
    static void Main(string[] args)
	{
    	PrintSomething(38);
        PrintSomething(41);
	}
    
    private static PrintSomething(int x)
    {
        Console.WriteLine($"{x}");
    }
}
}
```

两次执行`PrintSomething`时，两个内部identifier `x`是相互独立的。

同样的，用一个类的不同实例也是彼此独立的。同一个类的两个不同实例，不会对对方的内部identifiers造成影响。也就是说修改一个实例的字段不会影响另一个实例的同名字段。

方法多次执行之间的独立性以及类多个实例之间的独立性，是由程序执行时内存的分配策略决定的。当一个函数执行完，不仅意味着这个identifiers的作用域结束，也意味着内存回收。更详细的讨论留到内存管理相关章节。

## 成员访问控制

从identifiers绑定的机制上来说，只有从内部访问外部identifiers。但是从外部不能访问内部identifiers。但是从作用域外（不仅仅是从包含作用域的作用域去，也包括从其他完全不相干的作用域中）访问一个作用域内部的identifiers并不是完全不可能的。

回想一下刚刚介绍的命名空间系统。实际上我们加上完整的命名空间前缀访问命名空间内定义的类，就是在从命名空间作用域外访问其内部identifiers。也就是说通过作用域自身的identifier，加上成员运算符`.`可以访问作用域内部的identifiers。不过这种用法仅仅限于命名空间，类以及类的实例（对象）。方法不能这么用。

> 对于一个命名空间来说，其成员可能是命名空间或者类。而对于类（或者类的对象）来说，其成员可能是类，字段，方法，属性等等。这里我们把“能够访问一个成员的数据”和“这个成员的identifier的可见性”等同起来。

有了这种访问方法之后，我们还需要解决一个问题：有时候我们希望有的内部identifiers可以通过成员运算访问，而另一些内部identifiers不可以通过成员运算访问。这就需要控制成员的访问权限。C#提供两个层面上的访问控制：

- 物理层面上，assembly（程序集）内部可访问和外部可访问。
- 逻辑上，根据类的继承关系确定可访问性。

> “assembly”是一个.NET的概念。可以简单理解为一个可知性文件或者一个动态类库。也就是说编译后的一个后缀为`.exe`或者`.dll`的文件就是一个assembly。

在这两个控制层面上，现在C#提供了6个访问控制符。

### public

`public`表示物理上和逻辑上都不受任何限制。这个成员可以被其他任何代码访问（通过成员运算）。

这个修饰可以用于命名空间的成员，也可以用作类的成员。

### 物理层面限制

`internal`表示该成员只能被同属于一个assembly的代码访问。

这个修饰可以用于命名空间的成员，也可以用作类的成员。

仅仅受到物理层面的限制，说明不受逻辑层面限制。

### 逻辑层面的限制

逻辑层面的限制，仅仅能用于类成员。因为命名空间没有继承关系。

`protected`表示这个成员仅能被包含它的类内部的代码或者继承了这个类的类内部的代码访问。

`private`表示这个成员仅能被包含它的类内部的代码的代码访问。

仅仅受到逻辑层面限制，说明不受物理层面限制。

### 混合限制

混合限制也仅仅可以对类成员使用。同样因为命名空间没有继承关系，它的成员无法受到逻辑限制。

`protected
internal`表示这个成员能被两种代码访问：

- 包含它的类内部的代码或者继承了这个类的类内部的代码。
- 和它同属于一个assembly的代码。

以上这两个条件满足一个就能访问它（两个条件是“或”的关系）。

`private
protected` 表示这个成员能被一种同时满足以下两个条件的代码访问（两个条件都必须满足，是“且”的关系）：

- 这段代码应当和这个成员的定义属于一个assembly。
- 这段代码应当包含于这个成员所属于的类或者包含于这个成员所属于的类衍生的类。

### 默认限制和书写规则

如果你没有显式写明成员的访问权限。那么命名空间的成员默认访问权限修饰为`internal`，类成员的默认访问权限修饰为`private`[^1]。

如果要显式写明访问权限，首先不能混用多种修饰。例如不能写`public private`。而`protected
internal`这样的算是多个单词组成的一种修饰。

另外一个成员可能前边跟着多种修饰，一般来说访问权限的修饰要写到最前边。例如`public static partial class MyDemo`。

## 例程清单

- `NamespaceDemo` 演示了identifier的绑定。

[^1]: https://stackoverflow.com/questions/2521459/what-are-the-default-access-modifiers-in-c

