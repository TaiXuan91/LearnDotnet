# Delegates and Lambda Expressions

对于现代的语言来说，方法不能作为一等公民是个遗憾。具体来说，现代的语言中，方法应当可以像普通对象一样随时创建，用变量存储，并且能够当作函数的参数和返回值。但是语法上继承自C++和Java的C#偏偏又不把方法当作对象。好在C#通过Delegates（委托）和Lambda Expressions（Lambda表达式）来弥补了这个缺憾。

从C#语法上来说，委托是一个类型。它保存一个对象和一个字符串。当调用它的

实际上委托是一种用面向对象方法，在面向过程基础的语言中实现函数式语法特性的方法。



在类里定义一个代理，实际上相当于在类里定义一个类。（所以不要把委托类定义写在函数里。）

由于方法不能独立存在，所以都要通过对象和对象的方法名来访问。

> 如果委托保存的对象是`System.Type`类型的对象，委托会调用这个`Type`对象表示的类的方法。

从实现上说，委托实际上是类型安全的指针。

委托对象加圆括号的调用被重载了。

关于为啥Delegate没有Invoke（因为函数签名不一样，不能在接口里定义死）



实际上声明的委托都是继承自System.MulticastDelegate，而非直接继承自System.Delegate



泛型委托

Action

Func

一方面是泛型的，

另一方面，这两个泛型类是预定义的，省得自己定义了



需要注意，是委托对象成员，还是委托类成员。

lambda表达式实际上实现了动态绑定。

但是在C里边实现动态绑定是比较麻烦的。



lambda表达式解决创建函数的问题，同时提供名称和变量作用域的绑定

lambda表达式创建的函数默认是匿名的

在定义成员函数的时候可以直接用func() =>{}

动态绑定要在C++里实现，需要使用类。在C里实现要用结构体（其中包含指向自身的指针，以起到类似类的作用）



更进一步

GetAString firstStringMethod = new GetAString(x.ToString);

可以写成

GetAString firstStringMethod = x.ToString;